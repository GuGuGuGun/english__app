# 学习算法系统深度优化文档 (V3.0)
## 1. 核心设计理念
基于墨墨背单词与SuperMemo算法，针对“考研/高强度记忆”场景进行特化：
1.  **阶梯式学习**：新词不再“一步登天”，必须经过“短期记忆(10min) -> 长期记忆(1day)”的确认阶段。
2.  **即时反馈闭环**：错误的词（AGAIN）不会等到明天，而是在当前Session中强制重试，确保“今日事今日毕”。
3.  **拼写强化权重**：拼写模式作为比认词更深度的记忆提取，享有更高的间隔加成，但错误惩罚也更严厉。
---
## 2. 全局参数定义
### 2.1 时间口径
*   **切日时间**：凌晨 04:00。
*   **今日到期**：`next_review_time < (current_time - 4h).date_end`。
### 2.2 记忆因子约束
*   **初始值 (EF)**：2.5
*   **最小值**：1.3 (认词模式) / 1.1 (拼写模式，惩罚更严)
*   **最大值**：3.0
### 2.3 学习步长
用于新词学习或AGAIN重置后的初期巩固：
*   **Step 1 (AGAIN)**：1 分钟 (Session内即时重试)
*   **Step 2 (HARD/模糊)**：10 分钟 (短期记忆确认)
*   **Step 3 (GOOD/认识)**：1 天 (进入长期记忆曲线)
---
## 3. 认词模式算法优化
### 3.1 状态机与按钮映射
新词与复习词采用统一的评分逻辑，但间隔计算逻辑分离。
| 用户操作 | 质量评分 | 状态变更 | 进度统计 | 核心逻辑 |
| :--- | :--- | :--- | :--- | :--- |
| **不认识** | 0 | 降级/保持新词 | +0 | **重置**：进入 Step 1 (1分钟后重试)。 |
| **模糊** | 3 | 进入学习中 | +0 (新词) / +1 (复习) | **保守**：进入 Step 2 (10分钟后复习) 或 缩短复习间隔。 |
| **认识** | 5 | 进入已掌握 | +1 | **推进**：进入 Step 3 (1天后) 或 正常增长间隔。 |
### 3.2 核心调度逻辑 (伪代码实现)
```kotlin
fun calculateRecognitionSchedule(progress: LearningProgress, quality: Int): ScheduleResult {
    val now = System.currentTimeMillis()
    var ef = progress.ease_factor
    var interval = 0
    
    // 1. 更新 EF (SM-2 核心公式)
    ef = (ef - 0.8 + 0.28 * quality - 0.02 * quality * quality).coerceIn(1.3f, 3.0f)
    // 2. 计算间隔
    if (quality == 0) {
        // --- 不认识 ---
        // 逻辑：重置为“重学状态”，间隔设为1分钟
        interval = 1 
        ef = max(1.3f, ef - 0.2f) // 额外惩罚，降低记忆因子
        // 标记为需要 Session 内重试
        return ScheduleResult(intervalMinutes = 1, isImmediateRetry = true)
        
    } else if (progress.status == Status.NEW || progress.isRelearning) {
        // --- 新词/重学阶段 (基于步长) ---
        if (quality == 3) { 
            // 模糊：进入下一学习步长 (10分钟)
            interval = 10 
        } else { 
            // 认识：直接毕业，进入长期复习 (1天)
            interval = 24 * 60 
            progress.status = Status.LEARNING // 标记为已进入长期记忆池
        }
        
    } else {
        // --- 旧词复习 (基于 SM-2 变体) ---
        val oldInterval = progress.interval
        
        if (quality == 3) {
            // 模糊：间隔缩短 (取 原间隔*1.2 与 原间隔*EF 的较小值，防波动)
            // 参考：墨墨逻辑，模糊意味着记忆不清，不应大幅增长
            interval = (oldInterval * 1.2).toInt() 
            // 或者是更激进的缩减：interval = (oldInterval * 0.8).toInt()
            // 建议采用：保守推进
        } else {
            // 认识：正常 SM-2 增长
            interval = (oldInterval * ef).toInt()
            // 防止间隔突增过大 (安全阀)
            if (interval > oldInterval * 2.5) interval = (oldInterval * 2.5).toInt()
        }
    }
    return ScheduleResult(nextIntervalDays = interval / (24 * 60), newEF = ef)
}
```
---
## 4. 拼写模式算法优化
拼写模式复用认词逻辑，但引入**“主动回忆加成”**与**“肌肉记忆惩罚”**。
### 4.1 评分体系映射
| 用户行为 | 评分 | 逻辑处理 |
| :--- | :--- | :--- |
| **完美拼写** | 5 | **奖励**：在认词 GOOD 的基础上，间隔时间 **\* 1.1**。 |
| **提示后正确** | 4 | **折算**：等同于认词 GOOD，无额外奖励。 |
| **多次尝试成功** | 3 | **保守**：等同于认词 HARD，间隔保守增长。 |
| **拼写错误** | 0 | **重置**：等同于认词 AGAIN，强制 Session 重试 + 抄写惩罚。 |
### 4.2 交互增强：强制纠错闭环
拼写错误的处理流程必须强制建立肌肉记忆：
1.  **判定错误**：UI 展示对比（用户输入 vs 正确答案）。
2.  **强制抄写**：弹出输入框，要求用户完整、正确地输入一遍单词。
3.  **加入重试队列**：抄写完成后，将该词标记为 `Quality=0`，加入 Session 内的重试队列。
---
## 5. 队列调度策略
这是优化的核心，解决了“新词背不完”和“复习堆积”的矛盾。
### 5.1 队列优先级
`Session重试队列` > `今日到期复习` > `新词队列`
### 5.2 动态混合策略 (墨墨式)
不要一次性倒出所有新词，也不要死板地先复习后新词。采用**“穿插注入”**策略：
```kotlin
fun getNextCard(): Card? {
    // 1. 最高优先级：刚才答错的词 (Session内循环)
    //    确保错误的词在用户记忆犹新时再次出现
    if (retryQueue.isNotEmpty() && shouldRetryNow()) {
        return retryQueue.poll()
    }
    // 2. 次优先级：今日到期复习
    //    只有复习完欠债，才能学新词（或按比例混合）
    if (reviewQueue.isNotEmpty()) {
        // 策略：每复习 3 个旧词，允许插入 1 个新词 (3:1 比例)
        if (newWordQueue.isNotEmpty() && reviewSessionCount % 4 == 0) {
             return newWordQueue.poll() // 穿插新词，缓解枯燥
        }
        reviewSessionCount++
        return reviewQueue.poll()
    }
    // 3. 最低优先级：新词
    return newWordQueue.poll()
}
```
### 5.3 AGAIN 的“随机插入”优化
*   **参考前论**：AGAIN 的词不应总是立刻顶到最前，防止卡死。
*   **最终方案**：
    *   若队列长度 > 5：随机插入到队列第 `[2, length-1]` 的位置。
    *   若队列长度 <= 5：直接插入到队列尾部。
    *   这样既保证了“隔几个词再见”的复习效果，又避免了“死循环”的焦躁感。
---
## 6. 进度统计与展示
### 6.1 统计口径修正
*   **今日已背量**：仅计算 `Quality >= 3` (模糊/认识) 的词。
*   **新学词数**：新词完成 Step 2 (10分钟测试) 或 Step 3 (直接认识) 时计入。
*   **复习词数**：复习词完成评分 (非 AGAIN) 时计入。
### 6.2 掌握度判定
只有同时满足以下条件，才标记为 `MASTERED` (已掌握)：
1.  `interval >= 21 天`
2.  `review_count >= 2 次`
3.  `ease_factor >= 2.3`
---
## 7. 总结：优化后的用户体验流
1.  **新词学习**：用户选“认识” -> **明日再见**；选“模糊” -> **10分钟后考你**；选“不认识” -> **1分钟后马上再来**。
2.  **复习巩固**：用户选“模糊” -> 间隔仅微幅增长 (如 5天->6天)；用户选“认识” -> 间隔正常增长 (如 5天->12天)。
3.  **拼写强化**：拼对 -> 间隔加长 10%；拼错 -> **强制抄写** -> 1分钟后重考。
4.  **队列流转**：系统自动穿插新词与复习词，用户感知不到枯燥的切分，体验流畅。
