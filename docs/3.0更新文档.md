此文档是对 V2.0 文档的增量更新，旨在不破坏原有离线架构的前提下，提供可选的智能化辅助功能。
---
# 项目名称：考研离线背单词助手 开发需求文档 (V3.0 - AI增强版) - 安卓版
## 1. 模块概述
### 1.1 AI 增强背景
V3.0 版本在原有离线架构基础上，引入**可选的**第三方大模型 API 支持。旨在解决静态词书内容僵化、缺乏个性化记忆辅助的问题。
**核心原则**：
1.  **离线优先**：AI 功能为“增强层”，不配置或无网络时，应用保持完整的基础功能。
2.  **用户自治 (BYOK)**：采用“用户自带 Key”模式，开发者无需承担服务器及 Token 成本。
3.  **隐私安全**：API Key 本地加密存储，请求仅在用户触发时发起。
### 1.2 核心目标
1.  **智能例句生成**：针对考研真题风格，生成语境化例句。
2.  **个性化助记**：提供词根词缀分析、谐音联想、故事记忆法。
3.  **长难句解析**：在查词页支持粘贴长难句进行语法拆解。
4.  **配置灵活性**：支持 OpenAI 协议兼容的各类 API（智谱AI、DeepSeek 等）。
### 1.3 技术栈补充
*   **网络库**：OkHttp + Retrofit (用于 API 请求)
*   **安全组件**：Jetpack Security (EncryptedSharedPreferences) 用于加密存储 API Key
*   **JSON解析**：Gson 或 kotlinx.serialization
*   **权限**：新增 `android.permission.INTERNET`
---
## 2. 功能模块详细设计
### 2.1 AI 设置与管理模块 (核心入口)
#### 2.1.1 AI 实验室设置页
此功能位于“我的”页面中，作为 AI 功能的总控制台。
*   **总开关**：Master Switch，控制全局 AI 功能的启用/禁用。关闭后，所有 AI 入口隐藏。
*   **API 配置**：
    *   **服务商预设**：提供智谱AI、DeepSeek、OpenAI 等快捷选项（自动填充 Base URL）。
    *   **自定义端点**：允许用户输入 Base URL（支持 OpenAI 兼容格式）。
    *   **API Key 输入**：密码输入框，支持“显示/隐藏”切换。
    *   **模型选择**：用户可指定模型名称（如 `glm-4-flash`, `gpt-3.5-turbo`）。
*   **连通性测试**：点击“测试连接”按钮，发送简单请求验证 Key 有效性，返回成功/失败提示。
*   **额度管理 (可选)**：引导用户查看 API 余额的链接。
### 2.2 学习流程 AI 增强
#### 2.2.1 智能例句生成
*   **触发场景**：
    *   学习页卡片翻转后，例句区域下方显示“AI 生成真题例句”按钮。
    *   查词详情页例句区底部。
*   **交互逻辑**：
    *   点击按钮 -> 显示加载动画 -> 展示 AI 生成的例句（标记“AI生成”标签）。
    *   支持重新生成。
    *   **缓存策略**：生成后自动存入本地数据库，二次查看无需联网。
#### 2.2.2 智能助记魔法
*   **触发场景**：
    *   点击“不认识”或拼写错误后的反馈界面。
*   **交互逻辑**：
    *   显示“AI 助记”按钮。
    *   点击后生成词根词缀分析、谐音梗或记忆故事。
    *   格式要求：简短精炼，适合快速阅读。
### 2.3 查词页 AI 增强
*   **长难句解析模式**：
    *   查词页输入框支持长文本粘贴。
    *   识别到输入文本超过 20 个字符时，自动切换为“句子解析”模式。
    *   AI 返回：句子主干提取、语法成分标注、中文翻译。
---
## 3. 数据库设计变更
需在原有数据库中新增 AI 缓存表，避免用户重复消费 Token。
### 3.1 新增实体：AI 缓存表
用于存储所有通过 API 生成的内容。
| 字段名 | 类型 | 说明 |
| :--- | :--- | :--- |
| `id` | Long | Primary Key |
| `word_id` | Long | 关联的单词 ID (可为空，长难句场景不关联) |
| `query_content` | String | 查询的原文内容 (用于校验缓存) |
| `type` | String | 类型枚举：`EXAMPLE`(例句), `MEMORY_AID`(助记), `SENTENCE`(长难句) |
| `ai_content` | String | AI 返回的 Markdown 内容 |
| `model_name` | String | 生成时使用的模型名称 |
| `created_at` | Long | 创建时间 |
### 3.2 数据存储
API Key 等敏感配置不存入 Room，而是使用 **EncryptedSharedPreferences** 存储。
*   `ai_enabled` (Boolean)
*   `api_base_url` (String)
*   `api_key` (String) -> **加密存储**
*   `model_name` (String)
---
## 4. 安卓专属 UI/UX 设计 (新增)
### 4.1 “我的”页面新增入口
*   在设置区域新增“AI 实验室”入口。
*   **状态展示**：
    *   未配置：显示“未配置 API Key”。
    *   已配置：显示当前服务商名称或“已启用”。
### 4.2 学习页交互调整
*   **卡片底部**：新增“AI 灯泡”图标。
    *   未配置/未启用：点击弹出引导弹窗“配置 API Key 解锁智能助记”。
    *   已配置：点击弹出底部抽屉，展示 [生成例句] / [助记技巧]。
### 4.3 加载与错误反馈
*   **加载态**：按钮变为加载转圈，不可重复点击。
*   **错误态**：Toast 提示具体错误（如“余额不足”、“网络超时”、“API Key 错误”）。
*   **AI 内容标识**：AI 生成的内容卡片需有明显的“AI 生成”角标，底部附带提示“内容由 AI 生成，请甄别参考”。
---
## 5. 关键逻辑实现指南
### 5.1 安全存储工具类
```kotlin
object AISecureStorage {
    private const val PREFS_FILE_NAME = "ai_secure_prefs"
    private const val KEY_API_KEY = "api_key"
    private fun getEncryptedPrefs(context: Context): SharedPreferences {
        val masterKey = MasterKey.Builder(context)
            .setKeyScheme(MasterKey.KeyScheme.AES256_GCM)
            .build()
        return EncryptedSharedPreferences.create(
            context,
            PREFS_FILE_NAME,
            masterKey,
            EncryptedSharedPreferences.PrefKeyEncryptionScheme.AES256_SIV,
            EncryptedSharedPreferences.PrefValueEncryptionScheme.AES256_GCM
        )
    }
    fun saveApiKey(context: Context, key: String) {
        getEncryptedPrefs(context).edit().putString(KEY_API_KEY, key).apply()
    }
    fun getApiKey(context: Context): String? {
        return getEncryptedPrefs(context).getString(KEY_API_KEY, null)
    }
}
```
### 5.2 API 调用逻辑
```kotlin
class AIRepository(
    private val aiService: AIService, // Retrofit 接口
    private val cacheDao: AICacheDao,
    private val context: Context
) {
    suspend fun getAIContent(wordId: Long, word: String, type: String): Result<String> {
        // 1. 查本地缓存 (Cache First)
        cacheDao.getByWordIdAndType(wordId, type)?.let {
            return Result.success(it.ai_content)
        }
        // 2. 检查配置
        val config = loadConfig()
        if (!config.enabled) return Result.failure(Exception("AI未启用"))
        // 3. 构建 Prompt
        val prompt = when(type) {
            "EXAMPLE" -> "请为考研单词 '$word' 生成2个符合考研英语阅读风格的例句..."
            "MEMORY_AID" -> "请用词根词缀法或联想记忆法辅助记忆单词 '$word'..."
            else -> ""
        }
        // 4. 发起请求
        try {
            val response = aiService.chat(
                auth = "Bearer ${config.apiKey}",
                request = ChatRequest(model = config.model, messages = listOf(Message("user", prompt)))
            )
            
            val content = response.choices.first().message.content
            
            // 5. 存入缓存
            cacheDao.insert(AICache(word_id = wordId, type = type, ai_content = content))
            
            return Result.success(content)
        } catch (e: Exception) {
            return Result.failure(e)
        }
    }
}
```
### 5.3 UI 状态管理
```kotlin
// 学习页 UI 状态
data class LearningUiState(
    val word: Word? = null,
    val aiState: AIState = AIState.Idle
)
sealed class AIState {
    object Idle : AIState()           // 初始态
    object Loading : AIState()        // 加载中
    data class Success(val content: String) : AIState() // 成功
    data class Error(val msg: String) : AIState()       // 失败
}
```
---
## 6. 交付清单 (新增)
请 AI 开发者在现有工程基础上补充以下内容：
1.  **Model 层**：
    *   新增 `AICache` 实体与 `AICacheDao`。
    *   数据库迁移脚本（vCurrent -> vNext）。
    *   `AIConfig` 数据类。
2.  **Network 层**：
    *   `AIService` 接口定义（兼容 OpenAI Chat 格式）。
    *   `OkHttp` 拦截器（处理超时、日志）。
3.  **Repository 层**：
    *   `AIRepository`：封装 Prompt 模板、缓存逻辑、异常处理。
4.  **Utils 层**：
    *   `AISecureStorage`：加密存储工具类。
    *   `PromptTemplates`：Prompt 模板管理。
5.  **UI 层**：
    *   `AILabScreen`：AI 设置页面。
    *   `AIContentCard`：通用的 AI 内容展示组件（支持 Markdown 渲染）。
    *   在 `LearningScreen` 和 `SearchScreen` 中集成 AI 入口。
---
## 7. 风险与注意事项
1.  **成本提示**：在设置页必须明确提示用户“AI 功能消耗用户自备的 API 额度，建议开启流式输出以节省 Token”。
2.  **隐私合规**：在隐私协议中增加条款，说明 API Key 仅用于发起请求，不会上传至开发者服务器。
3.  **Key 泄露风险**：虽然使用了加密存储，但 Root 设备仍有风险，需在 UI 上给予用户风险提示。
4.  **网络异常**：需处理弱网环境下的超时重试机制，避免阻塞用户学习流程。
