该算法在标准 **SM-2 算法** 的基础上，针对考研学生的“记忆压力大、需要快速巩固”的特点进行了优化，核心改进在于：**引入“模糊”状态的差异化处理**、**即时反馈机制（Session内循环）**以及**更平滑的间隔曲线**。
---
### 1. 算法核心设计理念
市面上的优秀App通常对标准SM-2做以下改良，我们将采纳这些策略：
1.  **拒绝“一刀切”的重置**：标准SM-2中，一旦回答“错误”，间隔往往直接重置为0。优化算法中，“错误”分为“完全遗忘（不认识）”和“似曾相识（模糊）”，后者应保留部分记忆进度，避免挫败感。
2.  **Session内即时巩固**：在单次学习流程中，如果用户点击“不认识”，该单词不应仅仅存入数据库等待明天复习，而应**立即加入当前学习队列的尾部**，确保在本次学习结束前再滚一遍。
3.  **平滑的间隔曲线**：针对新词和短期记忆，采用比SM-2更保守（更密集）的复习节点（如：1分钟、10分钟、1天），而不是直接跨度过大。
---
### 2. 状态机与参数定义
#### 2.1 用户反馈映射
我们将用户在认词模式下的三个按钮映射为算法质量评分：
| 用户操作 | 算法定义 | 质量评分 | 语义说明 |
| :--- | :--- | :--- | :--- |
| **认识** | Recall | 5 | 反应迅速，无需提示，记忆清晰。 |
| **模糊** | Hesitate | 3 | 思考后想起，或记错词性/拼写，属于“边缘记忆”。 |
| **不认识** | Forgot | 0 | 完全陌生或记反了，记忆链条断裂。 |
#### 2.2 数据库关键字段
算法依赖数据库中存储的以下字段（参考文档3.3）：
*   `ease_factor` (记忆因子，初始建议 2.5)
*   `interval` (当前间隔天数，需在逻辑层计算)
*   `review_count` (复习次数)
*   `status` (0:新词, 1:学习中, 2:已掌握)
---
### 3. 核心算法逻辑
#### 3.1 调度计算函数
此函数在用户点击按钮后触发，返回下次复习的时间戳。
```kotlin
/**
 * 优化版 SM-2 调度算法
 * @param currentProgress 当前单词的学习进度实体
 * @param quality 用户反馈评分 (0=不认识, 3=模糊, 5=认识)
 */
fun calculateNextReview(currentProgress: LearningProgress, quality: Int): ScheduleResult {
    val now = System.currentTimeMillis()
    var ef = currentProgress.ease_factor
    var interval = 0
    var status = currentProgress.status
    
    // 1. 记忆因子 (EF) 更新逻辑
    // 公式优化：EF' = EF - 0.8 + 0.28*q - 0.02*q^2
    // 此公式比标准SM-2更敏感，"模糊"会轻微降低EF，"不认识"大幅降低
    ef = ef - 0.8 + 0.28 * quality - 0.02 * quality * quality
    
    // 限制 EF 范围 [1.3, 3.0]，防止间隔过短或过长
    ef = ef.coerceIn(1.3f, 3.0f)
    // 2. 间隔计算逻辑
    if (quality < 3) {
        // --- 情况A：不认识 或 严重模糊 ---
        // 策略：重置间隔，但保留EF（不完全抹杀历史努力）
        interval = 1 // 明天必须复习
        
        // 如果是新词，保持状态为新词；如果是已掌握，降级为“学习中”
        if (status == 2) status = 1 
        
    } else if (status == 0) {
        // --- 情况B：新词首次学习 ---
        // 策略：采用“艾宾浩斯遗忘曲线”的密集复习点
        // 认识 -> 1天后复习；模糊 -> 当天稍后或明天复习
        interval = if (quality >= 5) 1 else 0 // 0表示稍后复习（需转为短期队列）
        status = 1 // 状态变更为“学习中”
        
    } else {
        // --- 情况C：旧词复习 ---
        // 根据复习次数决定间隔增长策略
        val count = currentProgress.review_count
        
        if (count == 0) {
            interval = 1
        } else if (count == 1) {
            interval = 3  // 第一次复习通过，间隔设为3天（比SM-2的6天更保守）
        } else {
            // 后续复习：应用EF因子
            // 公式：Interval = Previous_Interval * EF
            // 为了更平滑，市面上App通常会取整
            interval = (currentProgress.interval * ef).toInt()
            
            // 防止间隔突增过大（例如上一次间隔是5天，下一次不应直接跳到12天）
            // 设定最大增长步长（例如不超过上一次间隔的2.5倍）
            if (interval > currentProgress.interval * 2.5) {
                interval = (currentProgress.interval * 2.5).toInt()
            }
        }
        
        // 连续2次以上复习且间隔>20天，标记为已掌握
        if (interval >= 21 && count >= 2) status = 2
    }
    // 3. 计算具体时间戳
    val nextReviewTime = now + (interval * 24 * 60 * 60 * 1000L)
    return ScheduleResult(
        nextReviewTime = nextReviewTime,
        newEaseFactor = ef,
        newInterval = interval,
        newStatus = status
    )
}
```
#### 3.2 学习队列调度逻辑
这是App在运行时的“选词算法”，决定了用户屏幕上出现什么单词。
**策略：优先级混合队列**
市面上主流App（如墨墨）通常采用“新词 + 复习词 + 即时复习词”混合推送。
```kotlin
// 伪代码逻辑
class LearningQueueManager {
    
    private val newWordQueue = LinkedList<Word>()   // 新词队列
    private val reviewQueue = LinkedList<Word>()    // 今日到期复习队列
    private val immediateRetryQueue = LinkedList<Word>() // 即时重试队列（刚才点“不认识”的）
    // 初始化加载
    fun loadDailyWords(bookId: Long) {
        // 1. 加载今日需复习的词
        reviewQueue.addAll(repository.getDueWords(bookId))
        // 2. 根据用户设定的新词量加载新词
        newWordQueue.addAll(repository.getNewWords(bookId, dailyTargetCount))
    }
    // 获取下一个单词
    fun getNextWord(): Word? {
        // 最高优先级：刚才答错的词（即时巩固，V2.0文档虽未明示，但此为优秀App标配）
        if (immediateRetryQueue.isNotEmpty()) {
            return immediateRetryQueue.poll()
        }
        
        // 策略：每复习3个旧词，插入1个新词（避免新词堆积造成压力）
        // 也可简化为：先复习完旧词，再学新词
        if (reviewQueue.isNotEmpty()) {
            return reviewQueue.poll()
        }
        
        return newWordQueue.poll()
    }
    // 处理用户反馈
    fun handleUserAction(word: Word, action: UserAction) {
        val result = calculateNextReview(word.progress, action.quality)
        
        if (action == UserAction.FORGOT) {
            // 【关键优化】：
            // 1. 数据库层面：安排明天复习
            repository.updateProgress(word.id, result)
            
            // 2. 队列层面：立即加入重试队列，确保本次学习中再出现一次
            // 这模拟了“连续强化”过程
            immediateRetryQueue.add(word)
            
        } else {
            // 认识/模糊：正常更新数据库，移出队列
            repository.updateProgress(word.id, result)
        }
    }
}
```
---
### 4. 算法优势总结
对比原始文档中的简单逻辑，本优化算法具有以下优势：
1.  **更人性化的“模糊”处理**：
    *   很多App将“模糊”视为“错误”，直接重置进度。
    *   本算法将“模糊”视为“弱记忆”，保留进度但缩短间隔，既避免挫败感，又强化了复习，符合考研学生“这就有点印象但想不全”的真实场景。
2.  **即时反馈闭环**：
    *   通过 `immediateRetryQueue`（即时重试队列），实现了“不认识 → 立即重学 → 本节结束前再测”的闭环。这是V2.0文档中“复习时间可视化”功能的完美补充——用户看到的是“明天复习”，但App保证了“当下学会”。
3.  **稳健的掌握度判定**：
    *   只有在间隔超过21天且复习次数>=2次时，才标记为“已掌握（status=2）”。这避免了用户短期突击刷词导致的虚假掌握。
4.  **透明化配合**：
    *   算法计算出的 `interval` 和 `ef` 可以直接映射到V2.0文档要求的UI文案：“根据您的记忆曲线，建议3天后复习”。
### 5. 建议的UI文案配合
*   **不认识**：“已加入今日重学队列，明日再次复习。”
*   **模糊**：“记忆稍显模糊，建议明日巩固。”
*   **认识**：“记忆深刻，下次复习时间为X天后。”
