该算法在文档要求的“二元判定（对/错）”基础上，引入了**“提示权重”**、**“主动重试机制”**以及**“强化因子”**，旨在解决“拼对但不确定”和“拼错直接放弃”的学习痛点。
---
### 1. 算法核心设计理念
1.  **主动回忆强化**：拼写是比认词更深度的记忆提取，因此**正确奖励应大于认词**（间隔拉得更长），**错误惩罚应更严厉**（记忆提取失败说明记忆痕迹极浅）。
2.  **提示成本机制**：文档提到的“首字母提示”和“长度提示”并非免费午餐。使用提示应当折算为“非完美记忆”，降低算法的评分。
3.  **即时纠错闭环**：拼错不应直接跳过，而应强制用户“重试”或“抄写”，确保在本次Session中建立正确的肌肉记忆。
---
### 2. 评分体系与状态映射
我们将用户的拼写行为映射为SM-2算法所需的 `quality` (0-5分)：
| 用户行为 | Quality评分 | 算法定义 | 调度逻辑 |
| :--- | :--- | :--- | :--- |
| **完美拼写** | **5 (Perfect)** | 无提示，完全正确 | 视同“认识”，且因付出了主动回忆努力，**间隔时间额外加成 10%**。 |
| **提示后正确** | **4 (Pass)** | 使用了首字母/长度提示 | 视同“认识”，但**记忆强度打折**，间隔时间按标准计算。 |
| **多次尝试正确** | **3 (Hesitate)** | 错误1次后，第2/3次才对 | 视同“模糊”，间隔重置为近期，**加入本节复习队列**。 |
| **拼写错误** | **0 (Fail)** | 多次错误或点击“记住了” | 视同“不认识”，**间隔重置**，强制纳入“高频重试队列”。 |
---
### 3. 核心算法实现
#### 3.1 拼写判定与评分逻辑
```kotlin
sealed class SpellingResult {
    data class Perfect(val quality: Int = 5) : SpellingResult()
    data class Hinted(val quality: Int = 4) : SpellingResult() // 使用了提示
    data class RetrySuccess(val quality: Int = 3) : SpellingResult() // 错误后纠正
    data class Failed(val quality: Int = 0) : SpellingResult()
}
/**
 * 拼写判定核心函数
 * @param input 用户输入
 * @param correctWord 正确单词
 * @param hintUsed 是否使用了提示
 * @param attemptCount 当前尝试次数
 */
fun evaluateSpelling(
    input: String, 
    correctWord: String, 
    hintUsed: Boolean, 
    attemptCount: Int
): SpellingResult {
    val isCorrect = input.trim().equals(correctWord, ignoreCase = true)
    if (isCorrect) {
        return when {
            hintUsed -> SpellingResult.Hinted() // 使用了提示，评分降级
            attemptCount > 1 -> SpellingResult.RetrySuccess() // 错过一次才对，评分降级
            else -> SpellingResult.Perfect() // 完美拼写
        }
    } else {
        // 输入错误
        return SpellingResult.Failed()
    }
}
```
#### 3.2 调度算法 (SM-2 改良版)
针对拼写模式，调整了 Ease Factor (记忆因子) 的计算权重。
```kotlin
/**
 * 拼写模式专用调度算法
 */
fun calculateSpellingSchedule(
    currentProgress: LearningProgress,
    result: SpellingResult
): ScheduleResult {
    val now = System.currentTimeMillis()
    var ef = currentProgress.ease_factor
    var interval = 0
    
    // 1. 根据 Quality 更新记忆因子 (EF)
    // 拼写错误(Easy Factor惩罚加重)或提示过多，会显著降低EF
    val quality = when(result) {
        is SpellingResult.Perfect -> 5
        is SpellingResult.Hinted -> 4
        is SpellingResult.RetrySuccess -> 3
        is SpellingResult.Failed -> 0
    }
    
    // SM-2 公式：EF' = EF + (0.1 - (5 - q) * (0.08 + (5 - q) * 0.02))
    // 优化：拼写错误的惩罚力度加大，EF最低降至1.1 (标准通常为1.3)
    ef = ef + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02))
    ef = ef.coerceIn(1.1f, 3.0f)
    // 2. 计算间隔
    when (result) {
        is SpellingResult.Perfect -> {
            // 完美拼写：间隔加成 10%，鼓励主动回忆
            interval = if (currentProgress.review_count == 0) 1 
                       else (currentProgress.interval * ef * 1.1).toInt()
        }
        is SpellingResult.Hinted -> {
            // 提示后正确：标准间隔
            interval = if (currentProgress.review_count == 0) 1 
                       else (currentProgress.interval * ef).toInt()
        }
        is SpellingResult.RetrySuccess -> {
            // 多次尝试才对：视为“模糊”，短期复习
            interval = 1 // 明天复习
        }
        is SpellingResult.Failed -> {
            // 完全错误：重置
            interval = 0 // 标记为0，稍后复习
            ef = max(1.3f, ef - 0.2f) // 额外惩罚
        }
    }
    // 3. 更新数据库字段 (包含文档新增的拼写计数字段)
    val newStatus = if (interval >= 21) 2 else 1
    val nextReviewTime = now + (interval * 24 * 60 * 60 * 1000L)
    
    return ScheduleResult(
        nextReviewTime = nextReviewTime,
        newEaseFactor = ef,
        newInterval = interval,
        newStatus = newStatus,
        spellCorrectCountUpdate = if (quality >= 4) 1 else 0, // 更新拼写正确次数
        spellWrongCountUpdate = if (quality < 3) 1 else 0     // 更新拼写错误次数
    )
}
```
---
### 4. 交互流程优化逻辑 (关键)
结合文档要求，单纯计算时间是不够的，必须优化用户的**即时学习路径**。
#### 4.1 错误时的“强制重试”逻辑
市面上优秀的App（如墨墨）在拼写错误时，不会立即跳过，而是要求用户**手动输入一遍正确拼写**才能继续。这比单纯点击“记住了”效果好得多。
**逻辑伪代码：**
```kotlin
fun onUserSubmit(input: String) {
    if (input == correctWord) {
        // --- 正确流程 ---
        playSound(R.raw.correct)
        viewModelScope.launch {
            repository.updateProgress(calculateSpellingSchedule(..., SpellingResult.Perfect))
        }
        moveToNextWord() // 自动跳转
    } else {
        // --- 错误流程 ---
        showCorrectAnswerComparison(input, correctWord) // UI：红色高亮错误字母
        showCopyInputField(correctWord) // UI：要求用户抄写一遍正确单词
        
        // 状态锁定：用户必须抄写正确，才能进入下一词
        // 此时记录状态为 Failed，并在后台更新数据库
        repository.updateProgress(calculateSpellingSchedule(..., SpellingResult.Failed))
        
        // 【关键优化】：将该词加入当前学习Session的“待重测队列”
        // 确保用户在抄写完跳过后，过几个单词会再次弹出该词进行重测
        learningQueue.addImmediateRetry(currentWord) 
    }
}
```
#### 4.2 提示按钮的扣分逻辑
用户点击“首字母提示”或“长度提示”按钮时，虽然UI上辅助了用户，但算法层应立即记录 `hintUsed = true`。
```kotlin
// ViewModel
fun onHintUsed(hintType: HintType) {
    _currentHintState.value = when(hintType) {
        HintType.FIRST_LETTER -> HintState(showFirstLetter = true)
        HintType.LENGTH -> HintState(showLength = true)
    }
    // 标记本轮使用了提示
    isHintUsedForCurrentWord = true
}
```
---
### 5. 数据库更新策略
根据V2.0文档的数据库设计，每次拼写操作需同步更新以下字段：
1.  **tb_learning_progress**:
    *   `spell_correct_count`: 仅当 Quality >= 4 时 +1。
    *   `spell_wrong_count`: 仅当 Quality = 0 时 +1。
    *   `ease_factor`: 根据算法动态更新。
    *   `next_review_time`: 核心调度结果。
2.  **tb_daily_stats** (每日统计):
    *   `spell_practice_count`: 每次提交答案（无论对错）均 +1。
    *   `duration_millis`: 累加拼写耗时。
### 6. 总结
这套优化算法相比文档中的基础逻辑，主要提升点在于：
1.  **颗粒度更细**：区分了“蒙对的”、“提示后对的”和“真会的”，避免虚假掌握。
2.  **强化肌肉记忆**：通过“抄写惩罚”和“即时重测队列”，确保错误单词被即时巩固。
3.  **正向激励**：完美拼写获得更长的复习间隔，激励用户认真记忆拼写。
